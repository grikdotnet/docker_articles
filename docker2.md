Полуавтоматическая винтовка с самонаведением на ногу
========

**Как не надо использовать Docker.**

Чтобы понимать эту статью надо знать базовые команды Dockerfile для создания изображений и принципы объектно-ориентированного дизайна. 

Открываю документацию любого официального образа сервисного ПО - например, [Nginx](https://hub.docker.com/_/nginx/) и нахожу раздел "How to use this image".
Нам предлагают создать свой образ на базе официального, скопировав в него наши файлы, настроить мапинг порта в мир, и подмонтировать свою папку с конфигами.
```
FROM ...
COPY . /usr/src/myapp
WORKDIR /usr/src/myapp
```

Да, нам предлагают унаследовать Model от View в одном звездном классе и заплатить за хранение на Docker Hub образов наших проприетарных приложений. Business, as usual.
Это же нам предлагают сделать в образах [PHP](https://hub.docker.com/_/php/), [Pyhon](https://github.com/docker-library/docs/blob/master/python/README.md), Ruby, и так далее. Для Python и Ruby даже сделаны версии с ONBUILD-триггерами на построение изображений-наследников, которыми приложение из папки будет скопировано в новый образ, "which should be all you need" - как 640 килобайт.

К счастью, решение известно так же давно как проблема. Банда четырех, создатель Java Джеймс Гослинг и Фаулер последние 20 лет твердят: используйте композицию вместо наследования.
Поэтому я положу рядом контейнеры с разными сервисами, создам адаптер, data transfer object, и свяжу их через конфиг.

Наследование я использую для расширения существующего функционала в рамках инкапсуляции с учетом принципа подстановки Лисков - например, для подключения к php нужных мне расширений и системных библиотек, которые эти расширения используют.

Продолжение: https://github.com/grikdotnet/docker_articles/blob/master/docker3.md