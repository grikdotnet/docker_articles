Docker myths and recipes. Data Volume container.
========
*незаконченная статья*

Начало: https://github.com/grikdotnet/docker_articles/blob/master/docker1.md

В docker есть любопытный инструмент, который называется [Data Volume сontainer](https://docs.docker.com/userguide/dockervolumes/#creating-and-mounting-a-data-volume-container). 
У меня он ассоциациируется с паттерном data transfer object.

Вот что нужно знать про тома в docker:
* Data Volume - это внешний для контейнера каталог, монтированный в контейнер.
* Если не указать какой каталог монтировать - будет создан новый каталог в /var/lib/docker/volumes/ с названием из 64 цифр в 16-ричной нотации.
 Пример: `docker create -v /shared_folder image_name`
* При удалении контейнера volume-каталоги не удаляются.
* В каталог /var/lib/docker/volumes/ доступ есть только для рута, так что просмотреть содержимое автоматически созданных томов можно через `sudo`
* Данные из тома не экспортируются при выполнении `docker export`, `docker save` и не сохранятся в образ командой `docker commit`.
* Если при монтировании указать несуществующий каталог, или к нему нет доступа - docker не выдаст никакой ошибки
* При подключении в контейнер внешнего каталога у него остаются uid/gid host-системы.

После удаления контейнеров разобораться к чему относятся тома в /var/lib/docker/volumes/ достаточно сложно. Удобнее монтировать свои каталоги чтобы можно было просматривать их содержимое и удалять при ненужности. Однако, в контейнерах обычно есть свои пользователи и группы со своими uid/gid. Как будут соотноситься пользователи в контейнере и gid/uid монтируемых каталогов предсказать невозможно.

Перефразируя "Адвокат дьявола", авторы docker дают нам тома в контейнерах, дарят этот экстраординарный подарок, а потом для своего ролика космических трюков устанавливает противоположные правила игры.
Расшаривай каталог между контейнерами - но будет сложно удалить. Монтируй свою папку и удаляй ее когда надо - но не распространяй в образе. Записывай файлы в образ и распространяй его - но не расшаривай между контейнерами!

Несмотря на проблемы, использовать в контейнерах общие разделяемые каталоги для хранения файлов приложения и базы данных очень удобно, а проблему можно подпереть костылем в виде пары shell-команд в Dockerfile.

В документации предлагают создавать volume container из образа операционной системы или базы данных.
Если такой контейнер экспортировать, в файл пойдет вся операционная система. Наследование от образа mysql добавит к размеру архива порядка 66 мегабайт при сжатии xz. Чтобы избежать этого я создаю контейнер от [Busybox](https://hub.docker.com/r/library/busybox/) - он позволяет выполнять простые команды и открывать терминал в контейнере, при этом добавляет в архив менее мегабайта.

**Подготовка образа с приложением**

Я создам образ с пустым volume и файлами приложения. При создании контейнера будет проверяться пустой ли каталог, подключенный как volume.
Если пустой - в него копируются файлы приложения. Если каталог не пустой - не копируются.
При создании контейнера из образа я монтирую в него в качестве тома свой каталог, и в него копируются файлв приложения.
Я могу редактировать файлы приложения и пересоздавать контейнер, подключая к нему свои файлы.
При желании я могу вернуться к начальному состоянию из образа, создав новый контейнер и подключив пустой каталог.

Копирую скрипты приложения в каталоге `source` и готовлю образ со скриптами:
```console
$ mkdir data_volume
$ cd data_volume/
$ cp ~/app source
$ vi Dockerfile
```

Вот содержимое Dockerfile, из которого я создам образ со своим приложением.
```Dockerfile
FROM busybox
VOLUME /scripts
COPY source /source/
CMD test "$(ls -A "/scripts/" 2>/dev/null)" || cp /source/* /scripts/
```
При создании контейнера выполнится команда из CMD. Если каталог `application/` пустой, в него будут скопированы скрипты приложения.

Создаю образ и контейнер с приложением:
```
$ docker build -t grikdotnet/application .
$ cd ..
$ mkdir application
$ docker run --name application -v "$(pwd)/application:/scripts" grikdotnet/application
```
Теперь у меня есть образ grikdotnet/application с приложением и контейнер с data volume `/scripts/`,
в который монтирован мой каталог ./application/. При первом запуске каталог в application/ копируются файлы приложения из образа.
Я могу подключить этот data volume в контейнер php.
Если при создании контейнера application каталог scripts/ будет не пустой, приложение в него скопировано не будет.
Так что я могу редактировать скрипты и пересоздавать volume container по желанию.

Здесь используется директива CMD, а не ENTRYPOINT чтобы при запуске контейнера с консолью не выполнялась команда копирования файлов.

Подключение к контейнеру php:
```
$ docker run -d --name=php7 \
	-v "$(pwd)/localetc:/usr/local/etc" \
	--volumes-from application/
	-v "$(pwd)/log:/var/log/php" \
	php:7-fpm >>log/docker.php.log 2>&1
```

Этот образ удобно экспортировать
```
~$ docker save grikdotnet/application | xz > application.dc.tar.xz
$ ls -lh application.dc.tar.xz
-rw-rw-r-- 1 gri gri 858K Sep  8 14:53 application.dc.tar.xz
```
и импортировать
```
$ docker rm application
$ docker rmi grikdotnet/application
$ cat application.dc.tar.xz | docker import - grikdotnet/application
gri@ubuntu:~$ docker images
REPOSITORY               TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
grikdotnet/application   latest              cfdcb70892b0        4 seconds ago       2.659 MB
...
```

Осталось настроить права доступа.
